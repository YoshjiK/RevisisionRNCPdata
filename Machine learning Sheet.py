# -*- coding: utf-8 -*-
"""Untitled16.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WRdroN9oNC9YaJch-dNw6hu66z3gn5OC
"""

# 📌 MACHINE LEARNING CHEAT SHEET - DATA ANALYST RNCP NIVEAU 7 📊

---

# 🧠 **INTRODUCTION AU MACHINE LEARNING**

Le **Machine Learning** (ML) permet aux ordinateurs d'apprendre à partir de données sans être explicitement programmés. Il est utilisé pour **prédire**, **classer** et **détecter des tendances**.

Types d'apprentissage :
- **Supervisé** : Apprentissage basé sur des données étiquetées (ex : classification d'images, régression des prix immobiliers).
- **Non supervisé** : Apprentissage basé sur des données non étiquetées (ex : segmentation de clients).
- **Apprentissage par renforcement** : Un agent apprend à interagir avec un environnement pour maximiser une récompense (ex : IA jouant aux échecs).

---

# 📥 **IMPORTATION DES LIBRAIRIES ESSENTIELLES**


import numpy as np  # Manipulation des tableaux de données
import pandas as pd  # Manipulation et analyse des données
import matplotlib.pyplot as plt  # Visualisation basique
import seaborn as sns  # Visualisation avancée
from sklearn.model_selection import train_test_split  # Séparation des données
from sklearn.preprocessing import StandardScaler  # Normalisation des données
from sklearn.linear_model import LinearRegression  # Modèle de régression linéaire
from sklearn.metrics import mean_squared_error, accuracy_score  # Évaluation des modèles
```

---

# 📊 **1. CHARGER ET PRÉPARER LES DONNÉES**

Avant d'entraîner un modèle, il faut charger et nettoyer les données.

```
# Charger un dataset exemple
df = pd.read_csv('data.csv')  # Charger un fichier CSV

# Afficher les premières lignes
df.head()

# Vérifier les valeurs manquantes
df.isnull().sum()

# Remplacer les valeurs manquantes par la moyenne
df.fillna(df.mean(), inplace=True)
```

---

# ✂️ **2. SÉPARER LES DONNÉES EN TRAIN ET TEST**

```
X = df.drop(columns=['target'])  # Features (variables indépendantes)
y = df['target']  # Target (variable à prédire)

# Séparer en données d'entraînement (80%) et de test (20%)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
```

---

# ⚖️ **3. NORMALISER LES DONNÉES**

Certains modèles fonctionnent mieux avec des données normalisées.

```python
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)
```

---

# 🔮 **4. ENTRAÎNER UN MODÈLE DE MACHINE LEARNING**

## 🔹 **RÉGRESSION LINÉAIRE (Prédiction d'une valeur continue)**
```python
model = LinearRegression()  # Initialisation du modèle
model.fit(X_train, y_train)  # Entraînement du modèle

# Prédiction sur les données de test
y_pred = model.predict(X_test)

# Évaluation du modèle
mse = mean_squared_error(y_test, y_pred)  # Erreur quadratique moyenne
print(f'Erreur quadratique moyenne : {mse}')
```

---

## 🔹 **CLASSIFICATION (Prédiction d'une catégorie)**

Exemple avec une **régression logistique**.

```python
from sklearn.linear_model import LogisticRegression

model = LogisticRegression()
model.fit(X_train, y_train)
y_pred = model.predict(X_test)

# Évaluation du modèle
accuracy = accuracy_score(y_test, y_pred)  # Précision du modèle
print(f'Précision : {accuracy}')
```

---

# 🎯 **5. INTERPRÉTATION DES RÉSULTATS**

- **Régression linéaire** → Une faible erreur indique une bonne prédiction.
- **Classification** → Une haute précision indique un bon modèle.
- **Visualisation** :

```python
plt.scatter(y_test, y_pred)
plt.xlabel('Valeurs réelles')
plt.ylabel('Prédictions')
plt.title('Comparaison des valeurs réelles vs prédictions')
plt.show()
```

---

# 🛠 **6. AMÉLIORATION DU MODÈLE**

- **Ajouter plus de données**
- **Essayer d'autres modèles (arbres de décision, forêts aléatoires, SVM, réseaux de neurones)**
- **Effectuer un réglage d'hyperparamètres (GridSearchCV, RandomizedSearchCV)**

💡 **Astuce** : Toujours tester plusieurs modèles et comparer leurs performances.

🚀 **Maintenant, tu peux appliquer ces concepts sur des datasets réels !**